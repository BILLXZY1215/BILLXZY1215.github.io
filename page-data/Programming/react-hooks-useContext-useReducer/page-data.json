{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/Programming/react-hooks-useContext-useReducer/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Zeyu's Blog"}},"markdownRemark":{"id":"d83689c2-71c7-5367-a42a-3fbf28c4d4e8","excerpt":"useContext 基础 先来看一个基本的例子： 通过  方法， 我们可以设定某一个 context 的初始值。 通过 ，我们可以限定 context 的作用范围。当 Provider 的 value 发生变化时，其所有子级消费者 （用到了 useContext 的子组件）都会 rerender…","html":"<h2>useContext 基础</h2>\n<p>先来看一个基本的例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// 第一步：创建需要共享的context\nconst ThemeContext = React.createContext('light');\n\nclass App extends React.Component {\n  render() {\n    // 第二步：使用 Provider 提供 ThemeContext 的值，Provider所包含的子树都可以直接访问ThemeContext的值\n    return (\n      &lt;ThemeContext.Provider value=\"dark\">\n        &lt;Toolbar />\n      &lt;/ThemeContext.Provider>\n    );\n  }\n}\n// Toolbar 组件并不需要透传 ThemeContext\nfunction Toolbar(props) {\n  return (\n    &lt;div>\n      &lt;ThemedButton />\n    &lt;/div>\n  );\n}\n\nfunction ThemedButton(props) {\n  // 第三步：使用共享 Context\n  const theme = useContext(ThemeContext);\n  render() {\n    return &lt;Button theme={theme} />;\n  }\n}</code></pre></div>\n<ul>\n<li>通过 <code class=\"language-text\">createContext</code> 方法， 我们可以设定某一个 context 的初始值。</li>\n<li>通过 <code class=\"language-text\">Provider</code>，我们可以限定 context 的作用范围。当 Provider 的 value 发生变化时，其所有子级消费者 （用到了 useContext 的子组件）都会 rerender。</li>\n<li>在上述例子中，<code class=\"language-text\">App</code> 和 <code class=\"language-text\">ThemedButton</code> 很明显是一个爷孙关系的组件，现在我们的需求很简单，如何绕过父亲，直接将爷爷拥有的东西传给孙子？答案是：在爷爷那里 <code class=\"language-text\">createContext</code>， 在孙子那里 <code class=\"language-text\">useContext</code>。</li>\n</ul>\n<p>接下来，问题来了：如果说孙子不想只拿到爷爷的宝贝，他很有想法，想将这个宝贝经过加工后变得更好，并和爷爷一起分享，这时候应该怎么做呢？</p>\n<p>传统的 react class component 的做法是，将爷爷的宝贝变成一个可修改的<code class=\"language-text\">state</code>， 并将 <code class=\"language-text\">setState</code> 方法一层层传递至孙子。这样，孙子就拥有了 <code class=\"language-text\">setState</code> 的权利。但我们现在有 context 了，不需要一层层传递就可以实现。想必读到这里我们已经可以猜到，在 <code class=\"language-text\">createContext</code> 的时候，直接传一个类似 <code class=\"language-text\">setState</code> 的方法，就可以解决这个问题。</p>\n<p>现在，你可能会说，这个简单，直接传一个 <code class=\"language-text\">useState</code> 不就解决问题了吗？这理论上当然没有问题，但实际上你可能并不希望直接用<code class=\"language-text\">setState</code> 的方法直接更新 state (可能会遇到一些比较复杂的 state 更新逻辑)，而是希望通过某种标准化的 action(dispatch) 来更新 state, 而且 dispatch 还避免了回调函数，所以使用 useContext() + useReducer()的组合会更加 flexible。</p>\n<h2>useReducer 基础</h2>\n<p>先来看一个例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const initialState = {count: 0};\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'increment':\n      return {count: state.count + 1};\n    case 'decrement':\n      return {count: state.count - 1};\n    default:\n      throw new Error();\n  }\n}\n\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  return (\n    &lt;>\n      Count: {state.count}\n      &lt;button onClick={() => dispatch({type: 'decrement'})}>-&lt;/button>\n      &lt;button onClick={() => dispatch({type: 'increment'})}>+&lt;/button>\n    &lt;/>\n  );\n}</code></pre></div>\n<ul>\n<li>\n<p>先定义和 <code class=\"language-text\">useReducer</code> 有关的东西：</p>\n<ul>\n<li>state: 可更改的值</li>\n<li>dispatch: 用来更改 state 的函数，参数形式是 ({xxx: &#x3C;希望 set 的值>})</li>\n<li>reducer: 用来判断 state 更改逻辑的函数，参数形式是 (state, action), 上面 dispatch 中的 xxx, 对应 action.xxx。这样就很浅显易懂了，得到了 action.xxx，便可以判断 state 将要如何变化，最后 return 和 initialState 的 type 相等的数据即可。</li>\n<li>initialState: 顾名思义，表示 state 的初始值。</li>\n</ul>\n</li>\n</ul>\n<h2>useState 和 useReducer 搭配使用</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//爷组件：\nconst initialState = {xxx}\nconst reducer = (state, action) => {\n  // 举例说明\n  switch (action.type){\n    case 'yyy':\n      return {xxx} // 对 state 进行更改并返回原有 state 格式\n    ...\n    ...\n  }\n}\nexport const context = createContext({state: initialState, dispatch: () => null})\nconst [state, dispatch] = useReducer(reducer, initialState)\n\n//孙组件：\nimport { context } from 爷组件;\nconst { state, dispatch } = useContext(context)\n//在后面合适的地方展示 state，或通过 dispatch 方法 修改 state。搞定！!</code></pre></div>\n<h2>总结</h2>\n<ul>\n<li>如果你的页面 state 很简单，可以直接使用 <code class=\"language-text\">useState</code></li>\n<li>如果你的页面 state 比较复杂（state 是一个对象或者 state 非常多散落在各处）请使用 <code class=\"language-text\">userReducer</code></li>\n<li>如果你的页面组件层级比较深，并且需要子组件触发 state 的变化，可以考虑 <code class=\"language-text\">useReducer</code> + <code class=\"language-text\">useContext</code></li>\n</ul>\n<h2>Reference</h2>\n<ol>\n<li><a href=\"https://reactjs.org/docs/hooks-reference.html#usereducer\">React Documents: useReducer</a></li>\n<li><a href=\"https://www.jianshu.com/p/eddb25cda5f0\">简书：这一次彻底搞定 useReducer - useContext 使用</a></li>\n<li><a href=\"https://stackoverflow.com/questions/54646553/usestate-vs-usereducer\">StackOverflow: useState vs useReducer</a></li>\n</ol>","frontmatter":{"title":"React Hooks: useContext + useReducer","date":"July 05, 2021","description":" useContext + useReducer 搭配用法 => 实现隔代组件传值和资源共享"}},"previous":{"fields":{"slug":"/Programming/mitmproxy/"},"frontmatter":{"title":"mitmproxy: a free and open source interactive HTTPS proxy"}},"next":{"fields":{"slug":"/Programming/const-let-var/"},"frontmatter":{"title":"Const vs Let vs Var"}}},"pageContext":{"id":"d83689c2-71c7-5367-a42a-3fbf28c4d4e8","previousPostId":"b1a1f5b9-33f7-5354-a2f6-48a4e9b9c4fd","nextPostId":"de14ad24-0a5d-50e2-857a-a215b51b0746"}},
    "staticQueryHashes": ["2841359383","3257411868"]}