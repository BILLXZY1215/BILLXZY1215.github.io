{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/Programming/js-closure/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Zeyu's Blog"}},"markdownRemark":{"id":"8898aba6-5b55-5b6f-bba1-03ec2e4642c1","excerpt":"执行上下文 JS 是通过执行上下文来运行的。一般来说，从启动程序开始，我们从  开始。在  中定义的变量，被称之为 。当程序调用一个函数时，将经历如下几个步骤： 当函数遇到  或  时，将会结束： 词法作用域 来个简单的例子： 在这里先说一下 JS…","html":"<h2>执行上下文</h2>\n<p>JS 是通过执行上下文来运行的。一般来说，从启动程序开始，我们从 <code class=\"language-text\">全局执行上下文</code> 开始。在 <code class=\"language-text\">全局执行上下文</code> 中定义的变量，被称之为 <code class=\"language-text\">全局变量</code>。当程序调用一个函数时，将经历如下几个步骤：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. JS 创建一个新的执行上下文，可以将其命名为 `XX函数执行上下文`，或 `本地执行上下文`。\n\n2. 在这个 `本地执行上下文` 中，可能定义了一些变量，我们把它们叫做执行这个执行上下文的 `本地变量`。\n\n3. 新的执行上下文被推到到执行堆栈中。可以将执行堆栈看作是一种保存程序在其执行中的位置的容器。</code></pre></div>\n<p>当函数遇到 <code class=\"language-text\">return</code> 或 <code class=\"language-text\">}</code> 时，将会结束：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. 这个本地执行上下文从执行堆栈中弹出。\n\n2. (Important) 函数将返回值返回给 `调用执行上下文` （也就是调用目前本地执行上下文的执行上下文），它可以是 `全局执行上下文`，也可以是另外一个函数的 `本地执行上下文`。返回的值可以是一个对象、一个数组、一个函数、一个布尔值等等，如果函数没有 return 语句，则返回 undefined 。\n\n3. 这个本地执行上下文被销毁，这个本地执行上下文中声明的所有变量都将被删除。</code></pre></div>\n<h2>词法作用域</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">一个函数可以访问在它的调用执行上下文中定义的变量。</code></pre></div>\n<p>来个简单的例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1: let val1 = 2\n2: function multiplyThis(n) {\n3:   let ret = n * val1\n4:   return ret\n5: }\n6: let multiplied = multiplyThis(6)\n7: console.log('example of scope:', multiplied)</code></pre></div>\n<p>在这里先说一下 JS 寻找变量的方法：先在 <code class=\"language-text\">本地执行上下文</code> 中找，如果找不到就往 <code class=\"language-text\">调用执行上下文</code> 中找，直到 <code class=\"language-text\">全局执行上下文</code>，如果还是找不到，那就为 <code class=\"language-text\">undefined</code>。</p>\n<p>接下来详细说一下上面这个例子的执行过程：</p>\n<ol>\n<li>在全局执行上下文中声明一个新的变量 <code class=\"language-text\">val1</code>，并将其赋值为 <code class=\"language-text\">2</code>。</li>\n<li>第 <code class=\"language-text\">2-5</code> 行，声明一个新的变量 <code class=\"language-text\">multiplyThis</code>，并给它分配一个函数定义。</li>\n<li>第 <code class=\"language-text\">6</code> 行，声明一个在全局执行上下文 <code class=\"language-text\">multiplied</code> 新变量。</li>\n<li>从全局执行上下文内存中查找变量 <code class=\"language-text\">multiplyThis</code>，并将其作为函数执行，传递数字 <code class=\"language-text\">6</code> 作为参数。</li>\n<li>新函数调用(创建新执行上下文），创建一个新的 <code class=\"language-text\">multiplyThis</code> 函数执行上下文。</li>\n<li>在 <code class=\"language-text\">multiplyThis</code> 执行上下文中，声明一个变量 <code class=\"language-text\">n</code> 并将其赋值为 <code class=\"language-text\">6</code>。</li>\n<li>第 <code class=\"language-text\">3</code> 行，在 <code class=\"language-text\">multiplyThis</code> 执行上下文中，声明一个变量 <code class=\"language-text\">ret</code>。</li>\n<li>继续第 <code class=\"language-text\">3</code> 行。对两个操作数 <code class=\"language-text\">n</code> 和 <code class=\"language-text\">val1</code> 进行乘法运算.在 <code class=\"language-text\">multiplyThis</code> 执行上下文中查找变量 <code class=\"language-text\">n</code>。我们在步骤 <code class=\"language-text\">6</code> 中声明了它，它的内容是数字 <code class=\"language-text\">6</code>。在 <code class=\"language-text\">multiplyThis</code> 执行上下文中查找变量 <code class=\"language-text\">val1</code>。<code class=\"language-text\">multiplyThis</code> 执行上下文没有一个标记为 <code class=\"language-text\">val1</code> 的变量。我们向调用上下文查找，调用上下文是全局执行上下文，在全局执行上下文中寻找 <code class=\"language-text\">val1</code>。它在步骤 <code class=\"language-text\">1</code> 中定义，数值是 <code class=\"language-text\">2</code>。</li>\n<li>继续第 <code class=\"language-text\">3</code> 行。将两个操作数相乘并将其赋值给 <code class=\"language-text\">ret</code> 变量，<code class=\"language-text\">6 \\* 2 = 12</code>，<code class=\"language-text\">ret</code> 现在值为 <code class=\"language-text\">12</code>。</li>\n<li>返回 <code class=\"language-text\">ret</code> 变量，销毁 <code class=\"language-text\">multiplyThis</code> 执行上下文及其变量 <code class=\"language-text\">ret</code> 和 <code class=\"language-text\">n</code> 。变量 <code class=\"language-text\">val1</code> 没有被销毁，因为它是全局执行上下文的一部分。</li>\n<li>回到第 <code class=\"language-text\">6</code> 行。在调用上下文中，数字 <code class=\"language-text\">12</code> 赋值给 <code class=\"language-text\">multiplied</code> 的变量。</li>\n<li>最后在第 <code class=\"language-text\">7</code> 行，我们在控制台中打印 <code class=\"language-text\">multiplied</code> 变量的值。</li>\n</ol>\n<h2>返回函数的函数</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> 1: let val = 7\n 2: function createAdder() {\n 3:   function addNumbers(a, b) {\n 4:     let ret = a + b\n 5:     return ret\n 6:   }\n 7:   return addNumbers\n 8: }\n 9: let adder = createAdder()\n10: let sum = adder(val, 8)\n11: console.log('example of function returning a function: ', sum)</code></pre></div>\n<ol>\n<li>第 <code class=\"language-text\">2-8</code> 行。我们在全局执行上下文中声明了一个名为 <code class=\"language-text\">createAdder</code> 的变量，并为其分配了一个函数定义。第 <code class=\"language-text\">3-7</code> 行描述了上述函数定义，和以前一样，在这一点上，我们没有直接讨论这个函数。我们只是将函数定义存储到那个变量 (<code class=\"language-text\">createAdder</code>) 中。</li>\n<li>第 <code class=\"language-text\">9</code> 行。我们在全局执行上下文中声明了一个名为 <code class=\"language-text\">adder</code> 的新变量，暂时，值为 <code class=\"language-text\">undefined</code>。</li>\n<li>第 <code class=\"language-text\">9</code> 行。我们看到括号 <code class=\"language-text\">()</code>，我们需要执行或调用一个函数，查找全局执行上下文的内存并查找名为 <code class=\"language-text\">createAdder</code> 的变量，它是在步骤 <code class=\"language-text\">2</code> 中创建的。好吧，我们调用它。</li>\n<li>调用函数时，执行到第 <code class=\"language-text\">2</code> 行。创建一个新的 <code class=\"language-text\">createAdder</code> 执行上下文。我们可以在 <code class=\"language-text\">createAdder</code> 的执行上下文中创建自有变量。<code class=\"language-text\">js</code> 引擎将 <code class=\"language-text\">createAdder</code> 的上下文添加到调用堆栈。这个函数没有参数，让我们直接跳到它的主体部分。</li>\n<li>第 <code class=\"language-text\">3-6</code> 行。我们有一个新的函数声明，我们在 createAdder 执行上下文中创建一个变量 <code class=\"language-text\">addNumbers</code>。这很重要，<code class=\"language-text\">addnumber</code> 只存在于 <code class=\"language-text\">createAdder</code> 执行上下文中。我们将函数定义存储在名为 <code class=\"language-text\">addNumbers</code> 的自有变量中。</li>\n<li>第 <code class=\"language-text\">7</code> 行，我们返回变量 <code class=\"language-text\">addNumbers</code> 的内容。js 引擎查找一个名为 <code class=\"language-text\">addNumbers</code> 的变量并找到它，这是一个函数定义。<strong>好的，函数可以返回任何东西，包括函数定义。我们返 <code class=\"language-text\">addNumbers</code> 的定义。</strong>第 <code class=\"language-text\">4</code> 行和第 <code class=\"language-text\">5</code> 行括号之间的内容构成该函数定义。</li>\n<li>返回时，<code class=\"language-text\">createAdder</code> 执行上下文将被销毁。<code class=\"language-text\">addNumbers</code> 变量不再存在。但 <code class=\"language-text\">addNumbers</code> 函数定义仍然存在，因为它返回并赋值给了 <code class=\"language-text\">adder</code> 变量。</li>\n<li>第 <code class=\"language-text\">10</code> 行。我们在全局执行上下文中定义了一个新的变量 <code class=\"language-text\">sum</code>，先赋值为 <code class=\"language-text\">undefined</code>;</li>\n<li>第 <code class=\"language-text\">1</code> 行。我们在全局执行上下文中声明一个变量 <code class=\"language-text\">val</code> 并赋值为 <code class=\"language-text\">7</code>。</li>\n<li>接下来我们需要执行一个函数。哪个函数? 是名为 <code class=\"language-text\">adder</code> 变量中定义的函数。我们在全局执行上下文中查找它，果然找到了它，这个函数有两个参数。</li>\n<li>让我们查找这两个参数，第一个是我们在步骤 <code class=\"language-text\">1</code> 中定义的变量 <code class=\"language-text\">val</code>，它表示数字 <code class=\"language-text\">7</code>，第二个是数字 <code class=\"language-text\">8</code>。</li>\n<li>现在我们要执行这个函数，函数定义概述在第 <code class=\"language-text\">3-5</code> 行，因为这个函数是匿名，为了方便理解，我们暂且叫它 <code class=\"language-text\">adder</code> 吧。这时创建一个 <code class=\"language-text\">adder</code> 函数执行上下文，在 <code class=\"language-text\">adder</code> 执行上下文中创建了两个新变量 <code class=\"language-text\">a</code> 和 <code class=\"language-text\">b</code>。它们分别被赋值为 <code class=\"language-text\">7</code> 和 <code class=\"language-text\">8</code>，因为这些是我们在上一步传递给函数的参数。</li>\n<li>第 <code class=\"language-text\">4</code> 行。在 <code class=\"language-text\">adder</code> 执行上下文中声明了一个名为 <code class=\"language-text\">ret</code> 的新变量。</li>\n<li>第 <code class=\"language-text\">4</code> 行。将变量 <code class=\"language-text\">a</code> 的内容和变量 <code class=\"language-text\">b</code> 的内容相加得 <code class=\"language-text\">15</code> 并赋给 <code class=\"language-text\">ret</code> 变量。</li>\n<li><code class=\"language-text\">ret</code> 变量从该函数返回。这个匿名函数执行上下文被销毁，从调用堆栈中删除，变量 <code class=\"language-text\">a</code>、<code class=\"language-text\">b</code> 和 <code class=\"language-text\">ret</code> 不再存在。</li>\n<li>返回值被分配给我们在步骤 <code class=\"language-text\">9</code> 中定义的 <code class=\"language-text\">sum</code> 变量。</li>\n<li>我们将 <code class=\"language-text\">sum</code> 的值打印到控制台。</li>\n<li>如预期，控制台将打印 15。我们在这里确实经历了很多困难，我想在这里说明几点。首先，函数定义可以存储在变量中，函数定义在程序调用之前是不可见的。其次，每次调用函数时，都会 (临时) 创建一个本地执行上下文。当函数完成时，执行上下文将消失。函数在遇到 <code class=\"language-text\">return</code> 或右括号 <code class=\"language-text\">}</code> 时执行完成。</li>\n</ol>\n<h2>一个闭包</h2>\n<p>下面这段代码会输出什么？</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> 1: function createCounter() {\n 2:   let counter = 0\n 3:   const myFunction = function() {\n 4:     counter = counter + 1\n 5:     return counter\n 6:   }\n 7:   return myFunction\n 8: }\n 9: const increment = createCounter()\n10: const c1 = increment()\n11: const c2 = increment()\n12: const c3 = increment()\n13: console.log('example increment: ', c1, c2, c3)</code></pre></div>\n<p>答案：<code class=\"language-text\">example increment: 123</code></p>\n<p>为什么不是 <code class=\"language-text\">example increment: 111</code> 呢？ 在第 <code class=\"language-text\">9</code> 行 <code class=\"language-text\">increment</code> 变量不是只是一个 <code class=\"language-text\">myFunction</code> 的函数定义吗？那么当 <code class=\"language-text\">c1</code> <code class=\"language-text\">c2</code> <code class=\"language-text\">c3</code> 调用它的时候， <code class=\"language-text\">counter</code> 不是会从 <code class=\"language-text\">undefined</code> 开始加 <code class=\"language-text\">1</code>，然后被销毁吗？不知怎么滴，<code class=\"language-text\">increment</code> 函数记住了那个 <code class=\"language-text\">cunter</code> 的值。这是怎么回事?</p>\n<p>==> <code class=\"language-text\">闭包机制</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">无论何时声明新函数并将其赋值给变量，都要存储函数定义和闭包。闭包包含在函数创建时作用域（函数内部）中的所有变量，它类似于背包。函数定义附带一个小背包，它的包中存储了函数定义创建时作用域中的所有变量。</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">闭包本质就是：上级作用域内变量的生命周期，因为被下级作用域内引用，而没有被释放。就导致上级作用域内的变量，等到下级作用域执行完以后才正常得到释放。\n\n「函数」和「函数内部能访问到的变量」的总和，就是一个闭包。</code></pre></div>\n<h2>另一个闭包</h2>\n<p>下面这段代码会输出什么？</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let c = 4\nfunction addX(x) {\n  return function(n) {\n     return n + x\n  }\n}\n// const addX = x => n => n + x\nconst addThree = addX(3)\nlet d = addThree(c)\nconsole.log('example partial application: ', d)</code></pre></div>\n<p>答案：<code class=\"language-text\">example partial application: 7</code></p>\n<p>简单来说，<code class=\"language-text\">addThree</code> 调用了函数 <code class=\"language-text\">addX</code>，并且得到一个 function 的定义 + 一个闭包（这个闭包中有变量 <code class=\"language-text\">X = 3</code>）。</p>\n<p>紧接着，变量 <code class=\"language-text\">d</code> 调用了 <code class=\"language-text\">addThree</code>，相当于调用了一个带有闭包的 function，最终得到了结果 <code class=\"language-text\">7</code>。</p>\n<h2>闭包的应用</h2>\n<h3>1. 模拟 Java Class 中的 私有变量</h3>\n<p>下面这个程序会输出什么？</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function foo() {\n  const secret = Math.trunc(Math.random()*100)\n  return function inner() {\n    console.log(`The secret number is ${secret}.`)\n  }\n}\nconst f = foo() // `secret` is not directly accessible from outside `foo`\nf() // The only way to retrieve `secret`, is to invoke `f`</code></pre></div>\n<p>答案：<code class=\"language-text\">The secret number is 70.</code> (一个 <code class=\"language-text\">0-100</code> 之间的随机整数)</p>\n<p>上面的例子告诉我们，<code class=\"language-text\">secret</code> 是一个 “私有变量”。因为 <code class=\"language-text\">f</code> 调用了 <code class=\"language-text\">foo()</code>，得到的是另一个 function 叫做 <code class=\"language-text\">inner</code>，并且带有一个闭包。而实际上这个闭包中，存在变量 <code class=\"language-text\">secret</code>。因此，只有当调用 <code class=\"language-text\">f()</code> 时，<code class=\"language-text\">secrect</code> 变量才能够显示出来。</p>\n<h3>2. 函数柯里化</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function curry(fn) {\n  const args = []\n  return function inner(arg) {\n    if(args.length === fn.length) return fn(...args)\n    args.push(arg)\n    return inner\n  }\n}\n\nfunction add(a, b) {\n  return a + b\n}\n\nconst curriedAdd = curry(add)\nconsole.log(curriedAdd(2)(3)()) // 5</code></pre></div>\n<p>在上面的例子中，<code class=\"language-text\">curry</code> 函数接收一个 <code class=\"language-text\">fn</code> 参数（是一个函数定义）。<code class=\"language-text\">curriedAdd</code> 调用 <code class=\"language-text\">curry</code> 并将函数 <code class=\"language-text\">add</code> 的定义传入 <code class=\"language-text\">curry</code>，返回 [ 函数 <code class=\"language-text\">inner</code>的定义，并带有一个闭包，这个闭包中存在变量 <code class=\"language-text\">args = [], fn = add</code> ]1⃣️。</p>\n<p>此时，先看 <code class=\"language-text\">curriedAdd(2)</code>，相当于调用了一次 1⃣️，此时 <code class=\"language-text\">args.length = 0</code>， <code class=\"language-text\">fn.length = 2</code>。所以，<code class=\"language-text\">args = [2]</code>。</p>\n<p>再看 <code class=\"language-text\">curriedAdd(2)(3)</code>，那么同理，此时 <code class=\"language-text\">args.length = 1</code>， <code class=\"language-text\">fn.length = 2</code>，所以 <code class=\"language-text\">args = [2, 3]</code>。</p>\n<p>让我们再调用一次，<code class=\"language-text\">curriedAdd(2)(3)()</code>，此时 <code class=\"language-text\">args.length = fn.length = 2</code>，因此返回的不再是 1⃣️ 了，而是 <code class=\"language-text\">fn</code>，也就是 <code class=\"language-text\">add</code> 函数，<code class=\"language-text\">...args</code> 代表对 <code class=\"language-text\">args</code> 中的内容进行解构，所以我们可以认为，它返回的就是 <code class=\"language-text\">add(2,3)</code> 的结果，也就是 <code class=\"language-text\">5</code>。</p>\n<h3>3. 事件驱动式编程</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const $ = document.querySelector.bind(document)\nconst BACKGROUND_COLOR = 'rgba(200,200,242,1)'\n\nfunction onClick() {\n  $('body').style.background = BACKGROUND_COLOR\n}\n\n$('button').addEventListener('click', onClick)</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;button>Set background color&lt;/button></code></pre></div>\n<p><code class=\"language-text\">BACKGROUND_COLOR</code> 作为 <code class=\"language-text\">onClick</code> 函数的闭包变量。</p>\n<h3>4. 函数模块化</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let namespace = {};\n\n(function foo(n) {\n  let numbers = []\n  function format(n) {\n    return Math.trunc(n)\n  }\n  function tick() {\n    numbers.push(Math.random() * 100)\n  }\n  function toString() {\n    return numbers.map(format)\n  }\n  n.counter = {\n    tick,\n    toString\n  }\n}(namespace))\n\nconst counter = namespace.counter\ncounter.tick()\ncounter.tick()\nconsole.log(counter.toString())</code></pre></div>\n<p>变量 <code class=\"language-text\">numbers</code> 被放在闭包中被更新。</p>\n<h2>更多例子</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function foo() {\n  let x = 42\n  let inner  = function() { console.log(x) }\n  x = x+1\n  return inner\n}\nvar f = foo()\nf() // logs 43</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function createObject() {\n  let x = 42;\n  return {\n    log() { console.log(x) },\n    increment() { x++ },\n    update(value) { x = value }\n  }\n}\n\nconst o = createObject()\no.increment()\no.log() // 43\no.update(5)\no.log() // 5\nconst p = createObject()\np.log() // 42</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function foo() {\n  var result = []\n  for (var i = 0; i &lt; 3; i++) {\n    result.push(function inner() { console.log(i) } )\n  }\n  return result\n}\n\nconst result = foo()\n// The following will print `3`, three times...\nfor (var i = 0; i &lt; 3; i++) {\n  result[i]()\n}</code></pre></div>\n<h2>Reference</h2>\n<ol>\n<li><a href=\"https://juejin.cn/post/6844903858636849159\">掘金：（前端小智）我从来不理解 JavaScript 闭包，直到有人这样向我解释它</a></li>\n<li><a href=\"https://stackoverflow.com/questions/111102/how-do-javascript-closures-work\">StackOverflow: How do JavaScript closures work?</a></li>\n</ol>","frontmatter":{"title":"Js Closure","date":"August 27, 2021","description":"浅谈 JS 闭包"}},"previous":{"fields":{"slug":"/Programming/react-native/"},"frontmatter":{"title":"React Native: react on iOS and Android"}},"next":{"fields":{"slug":"/Life/peking-2021-summer/"},"frontmatter":{"title":"Coding in Beijing"}}},"pageContext":{"id":"8898aba6-5b55-5b6f-bba1-03ec2e4642c1","previousPostId":"4aca9362-b055-5ed3-bb66-b60189539b0f","nextPostId":"152ca637-5d75-5d8b-ba99-c6c39a6827a5"}},
    "staticQueryHashes": ["2841359383","3257411868"]}